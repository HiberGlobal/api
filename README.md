# Hiber API

This is the protobuf specification of the Hiber GRPC API.

## Technical tools

### Protocol Buffers

Protobuf is Google's replacement for json.
It's a more efficient way to encode data, and allows you to generate the model code in multiple languages. 
Because server and client model are generated from the same source, there can be no confusion about the model.

For more information, take a look at:

- [Protobuf at Github](https://github.com/google/protobuf/wiki)
- [Google Protocol Buffers Developer Guide](https://developers.google.com/protocol-buffers/)

### GRPC

GRPC is a way of defining rpc services in the protobuf format.
GRPC is based on HTTP2 and formalized the networking, status responses and streaming implementation for API calls.
Because the specification generates both the client and server code, the specification is valid by default 
and API documentation is in one place.

For more information, take a look at:

- [GRPC Homepage](https://grpc.io/)
- [GRPC Concepts](https://grpc.io/docs/guides/concepts.html)
- [GRPC Language Guides](https://grpc.io/docs/)
- [GRPC at Github](https://github.com/grpc/grpc)

### GRPC Web

Since GRPC is base on HTTP2, it is not compatible with web browsers.
In order to support web-based applications, we have implemented the GRPC Web specification.
This allows GRPC calls from the browser, from the typescript code generated by the GRPC Web generator.

For more information, take a look at:

- [GRPC Web Specification](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)
- [GRPC Web on Github](https://github.com/improbable-eng/grpc-web/)

## Usage

First of all, have a look through the .proto files in this repository.
You will find that they are very easy to read, and we have tried to name everything as clearly as possible, 
so as to avoid unnecessary extra documentation.

To use the proto files, clone this repository and generate code in your preferred language:

- [C++](https://grpc.io/docs/tutorials/basic/c.html#generating-client-and-server-code)
- [C#](https://grpc.io/docs/tutorials/basic/csharp.html#generating-client-and-server-code)
- [Dart](https://grpc.io/docs/tutorials/basic/dart.html#generating-client-and-server-code)
- [Go](https://grpc.io/docs/tutorials/basic/go.html#generating-client-and-server-code)
- [Java](https://grpc.io/docs/tutorials/basic/java.html#generating-client-and-server-code)
- [Node](https://grpc.io/docs/tutorials/basic/node.html#creating-the-client)
- [Objective-C](https://grpc.io/docs/tutorials/basic/objective-c.html#generating-client-code)
- [PHP](https://grpc.io/docs/tutorials/basic/php.html#generating-client-code)
- [Python](https://grpc.io/docs/tutorials/basic/python.html#generating-client-and-server-code)
- [Ruby](https://grpc.io/docs/tutorials/basic/ruby.html#generating-client-and-server-code)

### Simple example

For example:

```
service CurrentUserService {
  rpc CurrentUser (CurrentUserRequest) returns (CurrentUser);
}

message CurrentUser {
  string id = 1;
  string email = 2;
  string name = 3;
  repeated string accounts = 4;
}

message CurrentUserRequest {
}
```

(Note that this is a reduced example and you should consult the actual proto file for the actual, up to date definition.)

This defines a service that has one rpc call, which expects and empty request object and returns a CurrentUser object.

For API client purposes, you can mostly ignore the numbers and see this as a data class.
Note the `repeated` keyword for the `accounts` field. This indicates an array of values. 

### List requests, selection objects and pagination

For many of our list calls, which can list items like modems, users, etc., we use a selection object to 
simplify the filtering of the data. 
Selection object can be used in multiple places, where appropriate and extract away any duplication that would 
otherwise cause.

For example:

```
service WebhookService {
  rpc List (ListRequest) returns (ListRequest.Response);
}

message Webhook {
  int64 id = 1;
  string account = 2;
  string description = 3;
  repeated api.tag.Tag tags = 4;
}

message WebhookSelection {
  string description = 1;
  string url = 2;
  Filter.Webhooks webhooks = 3;
  api.tag.TagSelection tags = 4;
}

message ListRequest {
  message Response {
    repeated Webhook webhooks = 1;
    ListRequest request = 2;
    Pagination.Result pagination = 3;
  }

  string account = 1;
  WebhookSelection selection = 2;
  Pagination pagination = 3;
}

message Pagination {
  message Result {
    int32 size = 1;
    int32 page = 2;
    int32 total = 3;
    int32 totalPages = 4;
    Pagination previous = 6;
    Pagination next = 7;
  }
  int32 size = 1;
  int32 page = 2;
}

```

(Note, again, that this is a reduced example.)

This code actually contains a few interesting things. First, nested messages.
These are used to denoted linked function, i.e. the `Response` message inside the `ListRequest`.

The `WebhookSelection` message contains the filters that can be applied to webhooks.
Note that the `WebhookSelection` message contains a `TagSelection` as well. 
This is another selection object, used to filter webhooks by tags.  

The `Pagination` message is used for to paginate the result. 
It's a simple page size and page number combination (where 0 is the first page). 
The `Pagination.Result` message also contains `size` and `page`, but has corrected the `size` field to a 
maximum value (or default value if it was 0).
For convenience, it also contains a previous and next `Pagination` object, for easy pagination.

Note that `ListRequest.Response` contains a `ListRequest`, which is a corrected version of the request.
Selection object may have certain defaults or value limits, which will be visible in the corrected request.

### Default values

Everything in protobuf has a default value, which has a few interesting complications. 

For example:

```
enum ContentType {
  DEFAULT = 0;
  JSON = 1;
  PROTO = 2;
}
```

Since protobuf has a default value for all objects, enum takes the first value as default value. 
To avoid the situation where omitting the field would still set a value, we've introduced the `DEFAULT` value.

```
message UpdateBoolean {
  bool updated = 1;
  bool value = 2;
}
```

Since false is the default value for a boolean, we need to distinguish between an omitted value and 
setting the value to false in an update object. 
For this, we've added an `UpdateBoolean` message (and `UpdateClearableString` and `UpdateZeroableInt` 
for string that can be set to empty, and ints that can be set to 0, respectively)

Usage is pretty simple, set a value in the object and set `updated` to true.

## Developing on our API

For development, we have set up endpoints under [dev.hiber.global](https://dev.hiber.global):

- [dev.hiber.global](https://dev.hiber.global): The Hiber web application
- [api.dev.hiber.global](https://api.dev.hiber.global) (or [grpc.dev.hiber.global](https://grpc.dev.hiber.global)):
The GRPC API, accessible over https on port 443 or 1443.
(Note that opening this url in your browser will not work, since it requires HTTP2.)
- [grpc.web.dev.hiber.global](https://grpc.web.dev.hiber.global): The GRPC Web API, used in the web application. 
 
Technically, you might be able to connect a normal GRPC client to the GRPC Web API, but this is not recommended.

### API Tokens

The Hiber API requires a token for all GRPC call, using a metadata field called `authorization` with value `bearer $YOUR_TOKEN_HERE`.

To get a token for our API, go to the web application at [dev.hiber.global](https://dev.hiber.global) and log in.
Once you are linked to an account (this process is defined in the api, but not implemented in the web interface yet)
you can create a token (using another token) on the API.

(Note: for pilot customers, a number of token can be generated in advance, so this process is not necessary.)
